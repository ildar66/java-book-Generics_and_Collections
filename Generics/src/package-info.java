/**
 * Part I. Generics
 * *
 * 1. Introduction:
 * 1.1 Generics {@link chapter01.section01}
 * 1.2 Boxing and Unboxing {@link chapter01.section02}
 * 1.3 Foreach {@link chapter01.section03}
 * 1.4 Generic Methods and Varargs {@link chapter01.section04}
 * 1.5 Assertions {@link chapter01.section05}
 * *
 * 2. Subtyping and Wildcards:
 * 2.1 Subtyping and the Substitution Principle {@link chapter02.section01}
 * 2.2 Wildcards with extends {@link chapter02.section02}
 * 2.3 Wildcards with super {@link chapter02.section03}
 * 2.4 The Get and Put Principle {@link chapter02.section04}
 * 2.5 Arrays {@link chapter02.section05}
 * 2.6 Wildcards Versus Type Parameters {@link chapter02.section06}
 * 2.7 Wildcard Capture {@link chapter02.section07}
 * 2.8 Restrictions on Wildcards {@link chapter02.section08}.
 * *
 * 3. Comparison and Bounds:
 * 3.1 Comparable {@link chapter03.section01}
 * 3.2 Maximum of a Collection {@link chapter03.section02}
 * 3.3 A Fruity Example {@link chapter03.section03}
 * 3.4 Comparator {@link chapter03.section04}
 * 3.5 Enumerated Types {@link chapter03.section05}
 * 3.6 Multiple Bounds {@link chapter03.section06}
 * 3.7 Bridges {@link chapter03.section07}
 * 3.8 Covariant Overriding {@link chapter03.section08}
 * *
 * 4. Declarations:
 * 4.1 Constructors {@link chapter04.section01}
 * 4.2 Static Members {@link chapter04.section02}
 * 4.3 Nested Classes {@link chapter04.section03}
 * 4.4 How Erasure Works {@link chapter04.section04}
 * *
 * 5. Evolution, Not Revolution:
 * 5.1 Legacy Library with Legacy Client {@link chapter05.section01}
 * 5.2 Generic Library with Generic Client {@link chapter05.section02}
 * 5.3 Generic Library with Legacy Client {@link chapter05.section03}
 * 5.4 Legacy Library with Generic Client {@link chapter05.section04}
 * 5.4.1 Evolving a Library using Minimal Changes {@link chapter05.section04.minimal}
 * 5.4.2 Evolving a Library using Stubs {@link chapter05.section04.stubs}
 * 5.4.3 Evolving a Library using Wrappers {@link chapter05.section04.wrapper}
 * 5.5 Conclusions.
 * *
 * 6. Reification:
 * 6.1 Reifiable Types {@link chapter06.section01}
 * 6.2 Instance Tests and Casts {@link chapter06.section02}
 * 6.3 Exception Handling {@link chapter06.section03}
 * 6.4 Array Creation {@link chapter06.section04}
 * 6.5 The Principle of Truth in Advertising {@link chapter06.section05}
 * 6.6 The Principle of Indecent Exposure {@link chapter06.section06}
 * 6.7 How to Define ArrayList {@link chapter06.section07}
 * 6.8 Array Creation and Varargs {@link chapter06.section08}
 * 6.9 Arrays as a Deprecated Type? {@link chapter06.section09}
 * 6.10 Summing Up.
 * *
 * 7. Reflection:
 * 7.1 Generics for Reflection {@link chapter07.section01}
 * 7.2 Reflected Types are Reifiable Types {@link chapter07.section02}
 * 7.3 Reflection for Primitive Types {@link chapter07.section03}
 * 7.4 A Generic Reflection Library {@link chapter07.section04}
 * 7.5 Reflection for Generics {@link chapter07.section05}
 * 7.6 Reflecting Generic Types {@link chapter07.section06}
 * *
 * 8. Effective Generics:
 * 8.1 Take Care when Calling Legacy Code {@link chapter08.section01}
 * 8.2 Use Checked Collections to Enforce Security {@link chapter08.section02}
 * 8.3 Specialize to Create Reifiable Types {@link chapter08.section03}
 * 8.4 Maintain Binary Compatibility {@link chapter08.section04}
 * *
 */
